import 'package:image/image.dart' as img;
import 'dart:io';
import 'dart:math';

/// Class that holds data generated by extract() function
///
///
/// CgColor(r,g,b,percentage)
///
///
/// CgColor(255,255,255,0.9)
class CgColor {
  final int r; //out of 255
  final int g;
  final int b;
  num percentage; // between 0 - 1
  CgColor(this.r, this.g, this.b, this.percentage);
}

/// Takes an image path & number of colors and returns a list of CgColor objects
///
///
/// NOTE: Does not take into account Alpha values, all outputs are considered to have an Alpha value of 255 or fully opaque
List<CgColor> extractColor(File imageFile, int numberColors) {
  // decodeNamedImage vs decodeImage

  // TODO: accept -> imageFile, image.asset,

  final image =
      img.decodeNamedImage(imageFile.path, imageFile.readAsBytesSync());
  if (image == null) {
    throw ArgumentError("imageNullError");
  }
  final u8rgba = image.convert(format: img.Format.uint8, numChannels: 3);
  List<int> samples = sample(u8rgba);
  var usedColors = getUsedColors(samples);

  // to sort by count/occurance) so able to get most dominant
  usedColors.sort(((a, b) => b[0].compareTo(a[0])));
  return getColors(samples, usedColors, numberColors);
}

/// Function takes an image as input and returns a list containing aggregated color data sampled from the image, based on its luminance and HSL values, stored in sets of 4 values for each color combination.
List<int> sample(img.Image image) {
  final mostSfBits = 192; //aka 0b11000000, most left 2bits of 8bits
  // cubes represent the number of color combinations this process can output
  final cubes = (pow(4, 7)).toInt();
  final width = image.width;
  final height = image.height;
  List<int> sample = List<int>.filled(cubes, 0, growable: false);
  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
      var rgb = image.getPixel(x, y);
      int r = rgb[0].toInt(), g = rgb[1].toInt(), b = rgb[2].toInt();
      List<int> listOfHsl = hsl(r, g, b);
      int relativeLuminance = (r * 0.2126 + g * 0.7152 + b * 0.0722).toInt();

      // packed includes values: luminance, hue, luminosity, red, green, blue
      // however, in actual colorgram.js, RGB is not included due to bug

      //the value in packed is calculated by these 6(3) values to get the index to store the rgb values in array sample
      int packed = (relativeLuminance & mostSfBits) << 4;
      packed |= ((listOfHsl[0]) & mostSfBits) << 2;
      packed |= ((listOfHsl[2]) & mostSfBits) << 0;

      // *4 as these 4 values are stored in sets of 4
      packed *= 4;
      sample[packed] += r;
      sample[packed + 1] += g;
      sample[packed + 2] += b;
      sample[packed + 3] += 1;
    }
  }

  return sample;
}

/// Function analyzes a list of sampled color data and returns a list of lists, where each inner list contains the count of occurrences and the index of the sampled color data that represents a used color.
List<List<int>> getUsedColors(List<int> samples) {
  // to obtain all colors that have appeared and how many times
  final cubes = (pow(4, 7)).toInt();
  List<List<int>> usedColors = [];
  for (int i = 0; i < cubes; i += 4) {
    int count = samples[i + 3];
    if (count != 0) {
      usedColors.add([count, i]);
    }
  }
  return usedColors;
}

/// Function returns the user stated number of colors or the max number of colors present, whichever is lower, in sequence of most dominant.
List<CgColor> getColors(
    List<int> samples, List<List<int>> usedColors, int numberColors) {
  int pixels = 0;
  List<CgColor> colors = [];
  numberColors = min(numberColors, usedColors.length);
  for (var list in usedColors.sublist(0, numberColors)) {
    // list[0] = count
    // list[1] = index
    int count = list[0];
    pixels += count;
    colors.add(CgColor(samples[list[1]] ~/ count, samples[list[1] + 1] ~/ count,
        samples[list[1] + 2] ~/ count, count));
  }
  for (var color in colors) {
    // calculating percentage dominance
    color.percentage = color.percentage / pixels;
  }
  return colors;
}

// converting using this method is ~2x faster than the rgbToHsl method in the build in library
// thanks to @obskyr
/// RGB to HSL convert method
List<int> hsl(int r, int g, int b) {
  int most, least;
  if (r > g) {
    if (b > r) {
      most = b;
      least = g;
    } else if (b > g) {
      most = r;
      least = g;
    } else {
      most = r;
      least = b;
    }
  } else {
    if (b > g) {
      most = b;
      least = r;
    } else if (b > r) {
      most = g;
      least = r;
    } else {
      most = g;
      least = b;
    }
  }

  int l = (most + least) >> 1;

  int h, s;
  if (most == least) {
    h = s = 0;
  } else {
    int diff = most - least;
    if (l > 127) {
      s = (diff * 255) ~/ (510 - most - least);
    } else {
      s = (diff * 255) ~/ (most + least);
    }

    if (most == r) {
      h = ((g - b) * 255) ~/ diff + (g < b ? 1530 : 0);
    } else if (most == g) {
      h = ((b - r) * 255) ~/ diff + 510;
    } else {
      h = ((r - g) * 255) ~/ diff + 1020;
    }
    h ~/= 6;
  }

  return [h, s, l];
}
