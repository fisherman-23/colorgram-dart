import 'dart:async';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'dart:math';
import 'dart:ui' as ui;

/// Class that holds data generated by extract() function
///
///
/// CgColor(r,g,b,percentage)
///
///
/// CgColor(255,255,255,0.9)
class CgColor {
  final int r; //out of 255
  final int g;
  final int b;
  num percentage; // between 0 - 1
  CgColor(this.r, this.g, this.b, this.percentage);
}

// function that converts a ImageProvider into an UI Image for processing
Future<ui.Image> getImageFromProvider(ImageProvider provider) {
  final Completer<ui.Image> completer = Completer();

  // Create a dummy image widget
  final Image image = Image(image: provider);

  // Create a listener to extract ui.Image when the image is resolved
  final ImageStreamListener listener =
      ImageStreamListener((ImageInfo info, bool _) {
    completer.complete(info.image);
  });

  // Load the image
  final ImageStream stream = image.image.resolve(ImageConfiguration.empty);
  stream.addListener(listener);

  return completer.future;
}

/// Takes an imageProvider & number of colors and returns a list of CgColor objects
///
///
/// NOTE: Does not take into account Alpha values, all outputs are considered to have an Alpha value of 255 or fully opaque
Future<List<CgColor>> extractColor(
    ImageProvider provider, int numberColors) async {
  ui.Image image = await getImageFromProvider(provider);

  var byteData = await image.toByteData();
  if (byteData == null) {
    throw ArgumentError("Error when converting Image to RGBA Array");
  }

  Uint8List data = byteData.buffer.asUint8List();

  List<int> samples = sampleFromList(data);
  var usedColors = getUsedColors(samples);

  // to sort by count/occurance) so able to get most dominant
  usedColors.sort(((a, b) => b[0].compareTo(a[0])));
  return getColors(samples, usedColors, numberColors);
}

/// Function takes an image's RGBA array as input and returns a list containing aggregated color data sampled from the image, based on its luminance and HSL values, stored in sets of 4 values for each color combination.
List<int> sampleFromList(List<int> imageRGBAList) {
  final mostSfBits = 192; //aka 0b11000000, most left 2bits of 8bits
  // cubes represent the number of color combinations this process can output
  final cubes = (pow(4, 7)).toInt();
  List<int> sample = List<int>.filled(cubes, 0, growable: false);
  final int numPixels = imageRGBAList.length;
  for (int i = 0; i < numPixels; i += 4) {
    int r = imageRGBAList[i],
        g = imageRGBAList[i + 1],
        b = imageRGBAList[i + 2];
    List<int> listOfHsl = hsl(r, g, b);
    int relativeLuminance = (r * 0.2126 + g * 0.7152 + b * 0.0722).toInt();

    // packed includes values: luminance, hue, luminosity, red, green, blue
    // however, in actual colorgram.js, RGB is not included due to bug

    //the value in packed is calculated by these 6(3) values to get the index to store the rgb values in array sample
    int packed = (relativeLuminance & mostSfBits) << 4;
    packed |= ((listOfHsl[0]) & mostSfBits) << 2;
    packed |= ((listOfHsl[2]) & mostSfBits) << 0;

    // *4 as these 4 values are stored in sets of 4
    packed *= 4;
    sample[packed] += r;
    sample[packed + 1] += g;
    sample[packed + 2] += b;
    sample[packed + 3] += 1;
  }

  return sample;
}

/// Function analyzes a list of sampled color data and returns a list of lists, where each inner list contains the count of occurrences and the index of the sampled color data that represents a used color.
List<List<int>> getUsedColors(List<int> samples) {
  // to obtain all colors that have appeared and how many times
  final cubes = (pow(4, 7)).toInt();
  List<List<int>> usedColors = [];
  for (int i = 0; i < cubes; i += 4) {
    int count = samples[i + 3];
    if (count != 0) {
      usedColors.add([count, i]);
    }
  }
  return usedColors;
}

/// Function returns the user stated number of colors or the max number of colors present, whichever is lower, in no sequence. Sorting is needed.
List<CgColor> getColors(
    List<int> samples, List<List<int>> usedColors, int numberColors) {
  int pixels = 0;
  List<CgColor> colors = [];
  numberColors = min(numberColors, usedColors.length);
  for (var list in usedColors.sublist(0, numberColors)) {
    // list[0] = count
    // list[1] = index
    int count = list[0];
    pixels += count;
    colors.add(CgColor(samples[list[1]] ~/ count, samples[list[1] + 1] ~/ count,
        samples[list[1] + 2] ~/ count, count));
  }
  for (var color in colors) {
    // calculating percentage dominance
    color.percentage = color.percentage / pixels;
  }
  return colors;
}

// converting using this method is ~2x faster than the rgbToHsl method in the build in library
// thanks to @obskyr
/// RGB to HSL convert method
List<int> hsl(int r, int g, int b) {
  int most, least;
  if (r > g) {
    if (b > r) {
      most = b;
      least = g;
    } else if (b > g) {
      most = r;
      least = g;
    } else {
      most = r;
      least = b;
    }
  } else {
    if (b > g) {
      most = b;
      least = r;
    } else if (b > r) {
      most = g;
      least = r;
    } else {
      most = g;
      least = b;
    }
  }

  int l = (most + least) >> 1;

  int h, s;
  if (most == least) {
    h = s = 0;
  } else {
    int diff = most - least;
    if (l > 127) {
      s = (diff * 255) ~/ (510 - most - least);
    } else {
      s = (diff * 255) ~/ (most + least);
    }

    if (most == r) {
      h = ((g - b) * 255) ~/ diff + (g < b ? 1530 : 0);
    } else if (most == g) {
      h = ((b - r) * 255) ~/ diff + 510;
    } else {
      h = ((r - g) * 255) ~/ diff + 1020;
    }
    h ~/= 6;
  }

  return [h, s, l];
}
